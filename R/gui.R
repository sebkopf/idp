##################
# Info messaging #
##################

# show an info message
# type - styling of the mssage, info, error, question, warning are the standard ones
# timer - time in seconds until message disappears automatically
# okButton - whether there is an ok button or not
IDP.showInfo<-function(idp, msg, type="question", timer=2, okButton=TRUE) {
  idp$gui$infoBar$setMessageType(type)
  idp$gui$infoLabel$setText(msg)
  idp$gui$infoBar$show()
  if (!okButton)
    idp$gui$infoOkButton$hide()  
  else
    idp$gui$infoOkButton$show()
  if (!is.null(timer)) {
    Sys.sleep(timer)
    IDP.hideInfo(idp)
  }
}

# hide info bar
IDP.hideInfo<-function(idp) {
  idp$gui$infoBar$hide()
}

############
# Main GUI #
############

# launch the user interface
IDP.gui<-function(idp) { 
  
  # show a small loading window
  load_win <- gwindow("Loading IDP...", width=400, height=100, visible=FALSE)
  load_grp <- ggroup(horizontal=FALSE, expand=TRUE, cont=load_win)
  addSpring(load_grp, expand=T)
  glabel("Loading User Interface, please wait...", cont=load_grp)
  addSpring(load_grp, expand=T)
  visible(load_win, TRUE)
  Sys.sleep(2)
  
  # keep track of whether the DSQDP is running
  IDP.running <<- TRUE

  ### main window
  idp$gui$win <- win.init(paste("Isodat Data Processor - version", packageVersion('idp')), 
                          width=1280, height=750, modal = idp$gui$modal, parent = idp$gui$parent)
#   if (idp$gui$modal) {
#     message("\nStarting IDP in modal mode (started via script).\n")
#     idp$gui$win<-gbasicdialog(title=paste("Isodate File Processor - version", packageVersion('idp')), do.buttons=FALSE, visible=FALSE, parent=idp$gui$parent)
#     size(idp$gui$win) <- c(1280, 750)
#   } else {
#     message("\nStarting IDP in window mode.\n")
#     idp$gui$win<-gwindow(paste("Isodate File Processor - version", packageVersion('idp')), width=1280, height=750, visible=FALSE, parent=idp$gui$parent)
#   }
  
  # make sure to kill modal run by setting running flag back to FALSE
  addHandlerDestroy(idp$gui$win, handler=function(h,...) { message("\nGoodbye!!"); IDP.running <<- FALSE })

  ### storing settings for easier modification
  tag(idp$gui$win, "settings")<-idp$settings
  
  ### major divisions
  wingrp<-ggroup(horizontal=FALSE, expand=TRUE, cont=idp$gui$win, spacing=0)
  if (idp$gui$modal)
    parent <- getToolkitWidget(wingrp) # get automatic toplevel gtkHBox generated by dialog
  else
    parent <- getToolkitWidget(wingrp)$getParent() # get automatic toplevel gtkHBox generated by gwindow
  parent['border-width']<-0 # remove border
  idp$gui$navgrp<-ggroup(horizontal=FALSE, cont=wingrp, spacing=0) # navigation group
  # left top
  glt<-ggroup(horizontal=FALSE, expand=TRUE) # left column file browser group
  # left bottom
  glb<-ggroup(horizontal=FALSE, expand=TRUE) # left column for file info
  glbGTK<-getToolkitWidget(glb) # gtk object
  glbGTK['border-width']<-5 # border with
  # right top
  grt<-ggroup(horizontal=TRUE, expand=TRUE) # right top
  plot.grp<-ggroup(horizontal=FALSE, expand=TRUE, container=grt) # plot grp in right top
  # right bottom
  grb<-ggroup(horizontal=TRUE, expand=TRUE) # right bottom
  tag(idp$gui$win, "tableGrp")<-ggroup(horizontal=FALSE, expand=TRUE, container=grb) # table grp in bottom right
  idp$gui$gl<-gpanedgroup(glt, glb, horizontal=FALSE, expand=TRUE) # left column
  idp$gui$gr<-gpanedgroup(grt, grb, horizontal=FALSE, expand=TRUE) # right column
  idp$gui$gall<-gpanedgroup(idp$gui$gl, idp$gui$gr, horizontal=TRUE, container=wingrp, expand=TRUE) # total window group
  
  ### files browser
  tag(idp$gui$win, "fileBrowserParentGrp")<-glt
  tag(idp$gui$win, "fileBrowserGrp")<-NULL
  
  # all the items of the file browser
  fileBrowser.items <- function(path = NULL, user.data=NULL) {
    topleveldir <- is.null(path)
    if (topleveldir) 
      path <- tag(idp$gui$win, "settings")$fileDirectory # start with file directory from the settings
    files <- file.info(dir(path=path, full.names=TRUE))[,c(1,2,3)] # get all files and folders
    files <- data.frame(Name=dir(path=path), Dir=files[,2], stringsAsFactors=FALSE)
    files <- files[union(which(files$Dir), grep("\\.cf$", files$Name)),] # only folders and .cf files
    files <- files[order(-files$Dir, files$Name),] # sort by folder vs file and then name
    if (topleveldir) # add "..." at the beginning (FIXME: could make sure that it's not added if at root but too lazy now)
      files <- rbind(data.frame(Name="...", Dir=FALSE), files)
    return(files)
  }
  
  # functions to determine which items have sub items and which icons to use
  fileBrowser.hasOffspring <- function(children,user.data=NULL, ...)return(children$Dir) # which items have subdirectories
  fileBrowser.icons <- function(children,user.data=NULL, ...) {
    x <- rep("gtk-new", length=nrow(children))
    x[which(children$Name=="...")] <- "gtk-directory" # top level folder
    x[children$Dir] <- "gtk-directory" # real folders
    return(x)
  }
  
  # function to remake the file tree when switching folders (FIXME: somehow looses ability for tree expansion...maybe something about how the tree is added?)
  fileBrowser.gui<-function() {
    if (!is.null(tag(idp$gui$win, "fileBrowserGrp")))
      delete(tag(idp$gui$win, "fileBrowserParentGrp"), tag(idp$gui$win, "fileBrowserGrp"))
    tag(idp$gui$win, "fileBrowserGrp") <- ggroup(expand=TRUE)
    add(tag(idp$gui$win, "fileBrowserParentGrp"), tag(idp$gui$win, "fileBrowserGrp"), expand=TRUE)
    tree<-gtree(fileBrowser.items, fileBrowser.hasOffspring, icon.FUN = fileBrowser.icons, container=tag(idp$gui$win, "fileBrowserGrp"), expand=TRUE, handler=function(h,...) {
      if (is.null(subpath <- svalue(h$obj[]))) { 
        path <- IDP.getSettings(idp, "fileDirectory")
        file <- svalue(h$obj)
      } else {
        path <- file.path(IDP.getSettings(idp, "fileDirectory"), do.call("file.path", args=as.list(subpath[-length(subpath)])))
        file <- subpath[length(subpath)]
      }
      
      newpath <- file.path(path, file) # assemble new path  
      if (identical(file, "...")) { # except: top level directory
        pathparts <- strsplit(path, .Platform$file.sep)[[1]]
        newpath <- do.call("file.path", args=as.list(pathparts[-length(pathparts)]))
      } 
      
      #message(newpath, "\n", path, "\n", file)
      if (file.info(newpath)$isdir) { # open directory
        IDP.setSettings(idp, list(fileDirectory = newpath))
        fileBrowser.gui()
      } else # open file
        IDP.openIsodatFile(idp, path, file)
    })
  }
  # --> file browser initialization is at the end because it needs other idp objects to be fully initialized
  
  ### file info group
  idp$gui$fileInfo<-list()
  idp$gui$fileInfo.nb<-gnotebook(cont = glb, expand=TRUE)
  fileInfo.layout <- glayout(cont = idp$gui$fileInfo.nb, expand=TRUE, label="File Info")
  fileInfo.layout[1, 1] <- "File:"
  fileInfo.layout[1, 2] <- (idp$gui$fileInfo$Filename <- glabel("", cont=fileInfo.layout))
  fileInfo.layout[2, 1] <- "GC:"
  fileInfo.layout[2, 2] <- (idp$gui$fileInfo$GCprogram <- glabel("", cont=fileInfo.layout))
  fileInfo.layout[3, 1] <- "AS:"
  fileInfo.layout[3, 2] <- (idp$gui$fileInfo$ASprogram <- glabel("", cont=fileInfo.layout))
  fileInfo.layout[4, 1] <- "MS:"
  fileInfo.layout[4, 2] <- (idp$gui$fileInfo$MSprogram <- glabel("", cont=fileInfo.layout))
  fileInfo.layout[5, 1] <- "H3:"
  fileInfo.layout[5, 2] <- (idp$gui$fileInfo$H3factor <- glabel("", cont=fileInfo.layout))
  
  ### file graph
  idp$gui$info.graph <- ggraphics(container=idp$gui$fileInfo.nb, label="Refs", expand=TRUE)
  idp$gui$data.graph <- ggraphics(container=idp$gui$fileInfo.nb, label="Data", expand=TRUE)
  
  ### plot grp
  idp$gui$pn <- pn.GUI(plot.grp, idp$gui$win, enablePlotLabel=FALSE, enableMenuButtons=FALSE, startWithTab=FALSE,
                       plotObjLoadHandler=function(obj) IDP.loadIsodatFileTab(idp, obj$plotinfo),
                       plotEventHandlers=list(
                         Changed = function(h,...) IDP.plotClickHandler(idp, h),
                         Doubleclick = function(h,...) IDP.plotDoubleClickHandler(idp, h),
                         Rightclick = function(h,...) IDP.plotRightClickHandler(idp, h))) 
  
  ### table grp
  tag(idp$gui$win, "dataTable") <- gtable(IDP.getEmptyPeakTable(idp), expand=TRUE, cont=tag(idp$gui$win, "tableGrp"))
  data_table_click_handler <-  function(h,...) {
    if ( length(svalue(h$obj, index = TRUE)) > 0 ) IDP.plot(idp) # replot to highlight the value
  }
  addHandlerClicked( tag(idp$gui$win, "dataTable"), handler = data_table_click_handler)
  
  ### menu and toolbar navigation actions
  nav.xml <- IDP.getNavXML()
  nav.actions <-
    list(## name, icon, label , accelerator , tooltip , callback
      list ("IDP" , NULL , "_IDP" , NULL , NULL , NULL ) ,
      list ("SaveToWorkspace" , "gtk-home" , "Save To Workspace" , "<ctrl>H" ,"Save settings to workspace" , function(...) { # include also data once ready
        IDP.showInfo(idp, "Saving to workspace...", timer=1, okButton=FALSE)
        IDP.save(idp)
        IDP.showInfo(idp, "Isodat File Processor settings succesfully saved to workspace.", timer=2, okButton=FALSE)
      } ) , 
      list ("Quit", "gtk-quit", "Quit", NULL, "Quit program", function(...) { if (gconfirm("Are you sure you want to quit?")) dispose(idp$gui$win) } ),
      list ("File" , NULL , "_File" , NULL , NULL , NULL ) , 
      list ("OpenFile" , "gtk-open" , "Open File" , "<ctrl>O" ,"Open isodat file" , function(...) message("sorry, file selection dialog not implemented yet") ) , 
      list ("CloseFile" , "gtk-close" , "Close File" , "<ctrl>W" ,"Close isodat file" , idp$gui$pn$actions$aClosePlot$handler ) , 
      list ("CloseAll" , "gtk-stop" , "Close all Files" , "<ctrl><shift>W" ,"Close all isodat files" , function(...) gmessage("sorry, not implemented yet") ) ,
      list ("ExportExcel" , "gtk-save-as" , "Export to Excel" , "<ctrl>X" , "Export raw data and peak table to excel" , function(...) idp.exportFileToExcel(idp) ) , 
      list ("ExportAll" , "gtk-harddisk" , "Export all to Excel" , "<ctrl><shift>X" , "Export peak table for all files" , function(...) idp.exportAllPeakTablesToExcel(idp, saveAll=TRUE) ) , 
      list ("Plot" , NULL , "_Chrom" , NULL , NULL , NULL ) , 
      list ("SavePlot", "gtk-save-as", "Save as PDF", "<ctrl>S", "Save chromatogram as PDF", idp$gui$pn$actions$aSavePlot$handler ),
      list ("SaveAll", "gtk-harddisk", "Save all", "<ctrl><shift>S", "Save all chromatograms as PDFs", idp$gui$pn$actions$aSaveAll$handler ),
      list ("PrintPlot", "gtk-print", "Print", NULL, "Print chromatogram", idp$gui$pn$actions$aPrintPlot$handler ),
      list ("Help" , "gtk-info" ,"Help" , NULL , NULL , function(...) gmessage("sorry, not implemented yet") ) ,
      list ("View" , NULL , "_View" , NULL , NULL , NULL ) ,
      list ("ZoomFull", "gtk-zoom-fit", "Unzoom", NULL, "Unzoom", function(h,...) IDP.zoomReset(idp) ),
      list ("ZoomBack", "gtk-undo", "Undo Zoom", "<ctrl>Z", "Return to previous zoom", function(h,...) IDP.zoomBack(idp) ),
      list ("ZoomIn", "gtk-zoom-in", "Zoom in", "<ctrl>P", "Zoom in", function(h,...) IDP.zoomIn(idp) ), # fix me, bertter short cuts?
      list ("ZoomOut", "gtk-zoom-out", "Zoom out", "<ctrl>M", "Zoom out", function(h,...) IDP.zoomOut(idp) ), # fix me, better short cuts?
      list ("MoveIntervalB", "gtk-go-back", "Move Left", "<ctrl><shift>Left", "Move visible window to the left", function (h,...) IDP.zoomMove(idp, -1)), # FIXME: shortcuts don't work
      list ("MoveIntervalF", "gtk-go-forward", "Move Right", "<ctrl><shift>Right", "Move visible window to the right", function (h,...) IDP.zoomMove(idp, +1)), # FIXME: shortcuts don't work
      list ("SetAxes", "gtk-page-setup", "Set Axes", NULL, "Set axis coordinates", function(h,...) gmessage("not implemented yet") ), # fix me, better short cuts?
      list ("DataTable" , NULL , "_Data" , NULL , NULL , NULL ) ,
      list ("StdsCalc" , NULL , "_Standards" , NULL , NULL , NULL ) ,
      list ("Mode" , NULL , "_Mode" , NULL , NULL , NULL ) ,
      list ("Settings" , NULL , "_Settings" , NULL , NULL , NULL ) , 
      list ("XUnits" , NULL , "_X-axis Units" , NULL , NULL , NULL ) ,
      list ("PlotOptions" , NULL , "_Plot Options" , NULL , NULL , NULL ) ,
      list ("EditSettings" , "gtk-preferences" , "_Edit Settings" , NULL , NULL , function(...) {gmessage("no editable settings implemented yet, sorry")} ) , 
      list ("TableColumns", "gtk-properties", "_Table Columns", NULL, "Select which peak table columns are displayed", function(...) {
        dlg <- gbasicdialog(title="Select visible columns for the peak table", handler = function(h,...) {
          tag(idp$gui$win, "settings")$peakTableColumns <- tbl[] # save updated peak table column settings
          delete(tag(idp$gui$win, "tableGrp"), tag(idp$gui$win, "dataTable")) # delete previous table
          tag(idp$gui$win, "dataTable")<-gtable(IDP.getEmptyPeakTable(idp), expand=TRUE, cont=tag(idp$gui$win, "tableGrp")) # remake current table
          addHandlerClicked( tag(idp$gui$win, "dataTable"), handler = data_table_click_handler)
          IDP.loadPeakTable(idp, pn.getAllInfo(idp$gui$pn)$peakTable)
        })
        size(dlg)<-c(500,500)
        tbl <- table.toggleTable(ggroup(cont=dlg, expand=TRUE), tag(idp$gui$win, "settings")$peakTableColumns, "Show", invisibleColumns=c("Name", "Required", "IsodatCol"))
        visible(dlg, set=TRUE) ## show dialog
      }),
      list ("DeletePeak" , "gtk-cancel" , "Delete Peak", "<ctrl>D", "Delete selected peak (<ctrl>D)" , function(...) { IDP.showInfo(idp, "Sorry, functionality not implemented yet", type="error", timer=2, okButton=FALSE)  }),
      list ("CopyTable" , "gtk-copy" , "Copy Table", "<ctrl>C", "Copy the peak table to the clipboard." , function(...) IDP.copyPeakTable(idp)),
      list ("Recalculate" , "gtk-execute" , "Re-evaluate", "<ctrl>R", "Recalculate the isotopic composition based on the standards picked." , function(...) IDP.recalculatePeakTable(idp)),
      list ("Revert" , "gtk-revert-to-saved" , "Revert All", NULL, "Discard all changes and return to original peak table from data file." , function(...) IDP.revertPeakTable(idp))
    )
  
  action_group <- gtkActionGroup ( "FileGroup" )
  action_group$addActions( nav.actions )
  
  ### special actions
  # full screen (toggle)
  fullscreen_act<-gtkToggleAction("FullScreen", "Full Screen", "Make application full screen", stock.id="gtk-fullscreen")
  gSignalConnect (fullscreen_act , "toggled" , function ( action ) {
    if(fullscreen_act ['active'] )
      getToolkitWidget(idp$gui$win)$fullscreen ( )
    else
      getToolkitWidget(idp$gui$win)$unfullscreen ( )
  } )
  action_group$addActionWithAccel(fullscreen_act, "<control>F")
  
  # switch between multiple options [generic implementation]
  optionsSwitch<-function(options, signals, action) {
    for (name in names(options)) {
      gSignalHandlerBlock(options[[name]], signals[[name]])
      options[[name]]['active'] <- identical(name, action$name)
      gSignalHandlerUnblock(options[[name]], signals[[name]])
    }
    return(action$name)
  }
  
  # switching x axis unit
  xaxisActs<-list(
    XaxisSec = gtkToggleAction("XaxisSec", "Seconds", "Show graph in seconds"),
    XaxisMin = gtkToggleAction("XaxisMin", "Minutes", "Show graph in minuts")
  )
  xaxisSignals<-list()
  for (name in names(xaxisActs)) {
    xaxisSignals[[name]] <- gSignalConnect (xaxisActs[[name]] , "toggled", function(action) {
      opt <- optionsSwitch(xaxisActs, xaxisSignals, action)
      tag(idp$gui$win, "settings")$plotOptions$xUnits$value <- which(idp$settings$plotOptions$xUnits$ids == opt)
      IDP.plot(idp) # replot
    })
    action_group$addAction(xaxisActs[[name]])
  }
  
  # plot options
  MarkRefsAct = gtkToggleAction("MarkRefs", "Mark Reference Peaks", "Mark reference peaks with *")
  MarkRefsAct['active']<-idp$settings$plotOptions$markRefs
  gSignalConnect (MarkRefsAct, "toggled" , function ( action ) {
    IDP.setSettings(idp, list("plotOptions.markRefs" = MarkRefsAct['active']))
    IDP.plot(idp) # replot
  } )
  action_group$addAction(MarkRefsAct)
  
  PeakDelimsOnAct = gtkToggleAction("PeakDelimsOn", "Show Peak Delimiters", "Show vertical lines to demarkate peaks")
  PeakDelimsOnAct['active']<-idp$settings$plotOptions$edgeMarker$on
  gSignalConnect (PeakDelimsOnAct, "toggled" , function ( action ) {
    IDP.setSettings(idp, list("plotOptions.edgeMarker.on" = PeakDelimsOnAct['active']))
    IDP.plot(idp) # replot
  } )
  action_group$addAction(PeakDelimsOnAct)
  
  ApexMarkerOnAct = gtkToggleAction("ApexMarkerOn", "Show Apex Marker", "Show vertical lines to demarkate peak apex")
  ApexMarkerOnAct['active']<-idp$settings$plotOptions$apexMarker$on
  gSignalConnect (ApexMarkerOnAct, "toggled" , function ( action ) {
    IDP.setSettings(idp, list("plotOptions.apexMarker.on" = ApexMarkerOnAct['active']))
    IDP.plot(idp) # replot
  } )
  action_group$addAction(ApexMarkerOnAct)
  
  # best fit (toggle)
  idp$gui$bestfitActive<-gtkToggleAction("BestFit", "Best Fit", "Fit to tallest peak", stock.id="gtk-zoom-100")
  gSignalConnect (idp$gui$bestfitActive , "toggled" , function ( action ) {
    if (idp$gui$bestfitActive['active'])
      IDP.zoomBest(idp)
  } )
  action_group$addActionWithAccel(idp$gui$bestfitActive, "<control>B")
  
  # switch between modes
  modeacts<-list(
    ModeInfo = gtkToggleAction("ModeInfo", "Information", "Select peaks for information", stock.id="gtk-leave-fullscreen"),
    ModeAdd = gtkToggleAction("ModeAdd", "Add Peak", "Add peaks", stock.id="gtk-add"),
    ModeEdit = gtkToggleAction("ModeEdit", "Edit Peak", "Edit peaks", stock.id="gtk-redo"),
    ModeRefs = gtkToggleAction("ModeRefs", "Choose Refs", "Choose isotopic reference peaks", stock.id="gtk-about"))
  modeact_IDs<-list()
  for (name in names(modeacts))
    modeact_IDs[[name]] <- gSignalConnect (modeacts[[name]] , "toggled" , function(action) tag(idp$gui$win, "settings")$mode<-optionsSwitch(modeacts, modeact_IDs, action))
  action_group$addActionWithAccel(modeacts$ModeInfo, "<control>I")
  action_group$addActionWithAccel(modeacts$ModeAdd, "<control>A")
  action_group$addActionWithAccel(modeacts$ModeEdit, "<control>E")
  action_group$addActionWithAccel(modeacts$ModeRefs, NULL) #FIXME (control - C taken by copy peak table)
  
  # switch between standards calc options
  stdsCalcActs <- list(
    Bracketing = gtkToggleAction("Bracketing", "Bracketing", "Use bracketing for standardization"),
    Regression = gtkToggleAction("Regression", "Regression", "Use regression for standardization"))
  stdsCalcSignals <- list()
  for (name in names(stdsCalcActs)) {
    stdsCalcSignals[[name]] <- gSignalConnect (stdsCalcActs[[name]] , "toggled" , function(action) {
        tag(idp$gui$win, "settings")$stdsCalc <- optionsSwitch(stdsCalcActs, stdsCalcSignals, action)
      })
    action_group$addAction(stdsCalcActs[[name]])
  }
  
  
  ### assemble menu
  uimanager <- gtkUIManagerNew() 
  uimanager$insertActionGroup ( action_group , 0)
  id <- uimanager$addUiFromString ( nav.xml )
  gtkNavgrp <- getToolkitWidget(idp$gui$navgrp) # get navgrp gtk object
  menubar <- uimanager$getWidget ( "/menubar" ) # menubar 
  gtkNavgrp$packStart ( menubar , FALSE )
  toolbar <- uimanager$getWidget ( "/toolbar" ) # toolbar
  gtkNavgrp$packStart ( toolbar , FALSE )
  getToolkitWidget(idp$gui$win)$addAccelGroup ( uimanager$getAccelGroup ( ) ) # add keyboard triggers
  
  ### add information bar
  idp$gui$infoBar <- gtkInfoBar (show=FALSE) 
  idp$gui$infoBar$setNoShowAll (TRUE)
  idp$gui$infoLabel <- gtkLabel ( "Warning , Warning")
  idp$gui$infoBar$setMessageType("question") 
  idp$gui$infoBar$getContentArea()$add(idp$gui$infoLabel)
  idp$gui$infoOkButton <-idp$gui$infoBar$addButton(button.text = "gtk-ok", response.id = GtkResponseType['ok'])
  gSignalConnect(idp$gui$infoBar, "response", function(infoBar, resp.id) IDP.hideInfo(idp))
  getToolkitWidget(wingrp)$packStart(idp$gui$infoBar, expand=FALSE)
  
  ### initialize file browser (this late so it has access to the different objects created later)
  fileBrowser.gui()
  
  ### make window visible after it's completely initialized
  optionsSwitch(modeacts, modeact_IDs, list(name=idp$settings$mode)) # select right option from the start
  optionsSwitch(xaxisActs, xaxisSignals, list(name=idp$settings$plotOptions$xUnits$ids[[idp$settings$plotOptions$xUnits$value]])) # select right xaxis from the start
  optionsSwitch(stdsCalcActs, stdsCalcSignals, list(name=idp$settings$stdsCalc)) # select right option from the start
  
  visHandler <- addHandlerFocus(idp$gui$win, handler=function(...) {
    svalue(idp$gui$fileInfo.nb) <- 1
    
    ### starting plot and notebook positions
    visible(idp$gui$info.graph) <- TRUE
    plot.new()
    text(0, 0, " ")
    visible(idp$gui$data.graph) <- TRUE
    plot.new()
    text(0, 0, " ")
    
    addHandlerChanged(idp$gui$fileInfo.nb, handler=function(h,...) {
      if (h$pageno ==2) IDP.plotRefs(idp)
      else if (h$pageno == 3) IDP.plotData(idp)
    })
    
    ### divider positions
    svalue(idp$gui$gl)<-IDP.getSettings(idp, "leftPane")
    svalue(idp$gui$gr)<-IDP.getSettings(idp, "rightPane")
    svalue(idp$gui$gall)<-IDP.getSettings(idp, "centerPane")
    
    # block Handler (only want it to fire once)  
    blockHandler(idp$gui$win, ID=visHandler)
  })
  
  ###### init #######
  # attach init event to focus handler (enables even modal dialog loading)
  visHandler <- addHandlerFocus(idp$gui$win, handler=function(...) {
    # initiate screen (load whatever needs to be loaded )
    
    # remove handler again
    blockHandler(idp$gui$win, ID=visHandler)
  })
  
  dispose(load_win)
  visible(idp$gui$win, TRUE)

  Sys.sleep(1)

  return (idp)
}

#FIXME: move all data related things to a data menu
#FIXME: move plot manipulation to plot menu
#FIXME: add menu item for copy peak table (to make shortcut work)
# get toolbar and navigation structure
IDP.getNavXML<-function() {
  ### menu and toolbar navigation structure
  nav.xml<-'<ui>
  <menubar name="menubar">
  <menu name = "IDP" action="IDP">
  <menuitem action="SaveToWorkspace" />
  <menuitem action="Help"/>
  <menuitem action="Quit" />
  </menu>
  <menu name ="FileMenu" action ="File">
  <menuitem action ="OpenFile" />
  <menuitem action ="CloseFile" />
  <menuitem action ="CloseAll" />
  </menu>
  <menu name="View" action="View">
  <menuitem action="ZoomBack"/>
  <menuitem action="ZoomFull"/>
  <menuitem action="ZoomIn"/>
  <menuitem action="ZoomOut"/>
  <menuitem action="BestFit"/>
  <menuitem action="MoveIntervalB"/>
  <menuitem action="MoveIntervalF"/>
  <menuitem action="SetAxes"/>
  <separator/>
  <menuitem action="FullScreen"/>
  </menu>
  <menu name="PlotMenu" action="Plot">
    <menu name="XUnits" action="XUnits">
      <menuitem action="XaxisSec"/>
      <menuitem action="XaxisMin"/>
    </menu>
    <menu name="PlotOptions" action="PlotOptions">
      <menuitem action="MarkRefs"/>
      <menuitem action="PeakDelimsOn"/>
      <menuitem action="ApexMarkerOn"/>
    </menu>
    <separator/>
    <menu name="Mode" action="Mode">
      <menuitem action ="ModeInfo"/>
      <menuitem action ="ModeAdd"/>
      <menuitem action ="ModeEdit"/>
      <menuitem action ="ModeRefs"/>
    </menu>
    <menuitem action ="DeletePeak"/>
    <separator/>
    <menuitem action="SavePlot"/>
    <menuitem action="SaveAll"/>
    <separator/>
    <menuitem action="PrintPlot"/>
  </menu>
  <menu name="DataTable" action="DataTable">
  <menu name="StdsCalc" action="StdsCalc">
    <menuitem action="Bracketing"/>
    <menuitem action="Regression"/>
  </menu>
  <separator/>
  <menuitem action ="CopyTable"/>
  <menuitem action="TableColumns"/>
  <separator/>
  <menuitem action ="ExportExcel" />
  <menuitem action ="ExportAll" />
  </menu>
  <menu name="Settings" action="Settings">  
  <menuitem action="EditSettings"/>
  </menu>
  </menubar>
  <toolbar name ="toolbar">
  <toolitem action = "ZoomFull"/>
  <toolitem action = "ZoomIn"/>
  <toolitem action = "ZoomOut"/>
  <toolitem action = "BestFit"/>
  <toolitem action = "MoveIntervalB"/>
  <toolitem action = "MoveIntervalF"/>
  <toolitem action ="SetAxes"/>
  <separator/>
  <toolitem action ="ModeInfo"/>
  <toolitem action ="ModeAdd"/>
  <toolitem action ="ModeEdit"/>
  <toolitem action ="DeletePeak"/>
  <toolitem action ="ModeRefs"/>
  <separator/>
  <toolitem action ="CopyTable"/>
  <toolitem action ="Recalculate"/>
  <toolitem action ="Revert"/>
  </toolbar>
  </ui>'
  return(nav.xml)
}



